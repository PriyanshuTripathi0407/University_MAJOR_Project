
--

### üîß **Main Issues in Your Models:**

1. **Incorrect product-to-vendor relation:**
   `VendorRegistration` has `product_list = models.ManyToManyField(Product)`.
   This should be a **reverse one-to-many**:
   ‚Üí One vendor **sells many products** ‚Üí `Product` should have a `ForeignKey` to `Vendor`.

2. **Product's vendor info is missing.**
   You need to add a `vendor = models.ForeignKey(VendorRegistration)` in the `Product` model.

3. **Redundant customer fields:**
   Fields like `favorite_vendor` and `favorite_product` are `CharFields`. Instead, they should be real relationships (`ForeignKey` or `ManyToManyField`).

---

### ‚úÖ **Fixed & Connected Models Example:**

Here's how you can update your models properly:

#### üîÅ Product (updated):

```python
class Product(models.Model):
    # ... your existing fields ...

    vendor = models.ForeignKey('VendorRegistration', on_delete=models.CASCADE, related_name='products')  # new!

    def generate_product_id(self):
        product_name_initial = self.product_name[0].upper() if self.product_name else "N"
        category_initial = self.product_category.name[0].upper() if self.product_category else "C"
        tag_initial = self.product_tag.first().name[0].upper() if self.product_tag.exists() else "T"
        product_id_number = f"{self.pk:03d}" if self.pk else "001"
        return f"{product_name_initial}{category_initial}{tag_initial}{product_id_number}"
```

#### üë§ VendorRegistration (updated):

```python
class VendorRegistration(models.Model):
    first_name = models.CharField(max_length=100, null=True, blank=True)
    last_name = models.CharField(max_length=100, null=True, blank=True)
    shop_name = models.CharField(max_length=200, null=True, blank=True)
    address = models.TextField(null=True, blank=True)
    contact = models.IntegerField(null=True, blank=True)
    email = models.EmailField(null=True, blank=True)
    image = models.ImageField(upload_to='product_images/', null=True, blank=True)
    role = models.ForeignKey(Role, on_delete=models.SET_NULL, null=True, blank=True)

    def __str__(self):
        return f"{self.shop_name}"
```

‚û°Ô∏è **Removed** `product_list = models.ManyToManyField(Product)` ‚Äî now it's connected through `Product.vendor`.

#### üë• CustomerRegistration (updated):

```python
class CustomerRegistration(models.Model):
    first_name = models.CharField(max_length=100, null=True, blank=True)
    last_name = models.CharField(max_length=100, null=True, blank=True)
    contact = models.IntegerField(null=True, blank=True)
    email = models.EmailField(null=True, blank=True)
    password = models.CharField(max_length=20, null=True, blank=True)
    confirmpassword = models.CharField(max_length=20, null=True, blank=True)
    image = models.ImageField(upload_to='product_images/', null=True, blank=True)
    
    favorite_vendors = models.ManyToManyField('VendorRegistration', blank=True)  # updated
    favorite_products = models.ManyToManyField('Product', blank=True)  # updated

    role = models.ForeignKey(Role, on_delete=models.SET_NULL, null=True, blank=True)

    def __str__(self):
        return f"{self.first_name} {self.last_name}"
```

---

### üîó Summary of Relationships:

| Model              | Relationship                            |
| ------------------ | --------------------------------------- |
| Product ‚Üí Vendor   | `ForeignKey` (many products per vendor) |
| Customer ‚Üí Vendor  | `ManyToManyField` (favorite vendors)    |
| Customer ‚Üí Product | `ManyToManyField` (favorite products)   |

---

### üåê React/Django API Tips

* Use **Django REST Framework (DRF)** to expose these models to React.
* Use `ModelSerializer` for each model.
* Use nested serializers or `.select_related()` / `.prefetch_related()` for efficiency.

---














* For **Customer Dashboard**:

  * Recently **viewed**, **searched**, **added-to-cart**, and **ordered** products
  * Favorite products/vendors
  * Top products (e.g. trending or highest rated)

* For **Seller Dashboard**:

  * Vendor info
  * Vendor's products list
  * Vendor's **sold products**, **orders**, and **customer reviews**
  * List of **customers who bought** from them

---

## ‚úÖ Here's how to support all this data:

### 1. üì¶ Add Tracking Models (Viewed, Cart, Orders, etc.)

#### **ViewedProduct**

```python
class ViewedProduct(models.Model):
    customer = models.ForeignKey(CustomerRegistration, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    viewed_at = models.DateTimeField(auto_now_add=True)
```

#### **SearchedProduct** (optional if tracked)

```python
class SearchedProduct(models.Model):
    customer = models.ForeignKey(CustomerRegistration, on_delete=models.CASCADE)
    query = models.CharField(max_length=255)
    searched_at = models.DateTimeField(auto_now_add=True)
```

#### **Cart**

```python
class CartItem(models.Model):
    customer = models.ForeignKey(CustomerRegistration, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveIntegerField(default=1)
    added_at = models.DateTimeField(auto_now_add=True)
```

#### **Order and OrderItem**

```python
class Order(models.Model):
    customer = models.ForeignKey(CustomerRegistration, on_delete=models.CASCADE)
    vendor = models.ForeignKey(VendorRegistration, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=30, default="Pending")  # or use choices

class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name="items")
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveIntegerField()
```

#### **ProductReview**

```python
class ProductReview(models.Model):
    customer = models.ForeignKey(CustomerRegistration, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    rating = models.DecimalField(max_digits=2, decimal_places=1)
    review = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
```

---

## üß† Now You Can Fetch Data Like:

### Customer Dashboard:

| Section              | Query Logic                                                                         |
| -------------------- | ----------------------------------------------------------------------------------- |
| Viewed Products      | `ViewedProduct.objects.filter(customer=customer_id).order_by('-viewed_at')[:5]`     |
| Searched Products    | `SearchedProduct.objects.filter(customer=customer_id).order_by('-searched_at')[:5]` |
| Add to Cart Products | `CartItem.objects.filter(customer=customer_id)`                                     |
| Ordered Products     | `Order.objects.filter(customer=customer_id).prefetch_related('items__product')`     |
| Top Products         | `Product.objects.order_by('-product_rating')[:10]`                                  |

---

### Seller Dashboard:

| Section          | Query Logic                                                        |
| ---------------- | ------------------------------------------------------------------ |
| Vendor Details   | `VendorRegistration.objects.get(id=vendor_id)`                     |
| Products List    | `Product.objects.filter(vendor=vendor_id)`                         |
| Sold Products    | `OrderItem.objects.filter(product__vendor=vendor_id)`              |
| Ordered Products | `Order.objects.filter(vendor=vendor_id).prefetch_related('items')` |
| Customer Reviews | `ProductReview.objects.filter(product__vendor=vendor_id)`          |
| Customers Table  | Get unique customers from orders:                                  |

```python
CustomerRegistration.objects.filter(order__vendor=vendor_id).distinct()
```

---

## üîå API Integration with React (using Django REST Framework)

You‚Äôll want API endpoints like:

* `/api/customer/<id>/dashboard/`
* `/api/vendor/<id>/dashboard/`

Then create custom views or DRF ViewSets that return structured JSON containing all the needed info.

Example response for **customer dashboard**:

```json
{
  "viewed_products": [...],
  "searched_products": [...],
  "cart_items": [...],
  "orders": [...],
  "top_products": [...]
}
```

And for **seller dashboard**:

```json
{
  "vendor_info": {...},
  "products": [...],
  "sold_products": [...],
  "orders": [...],
  "reviews": [...],
  "customers": [...]
}
```

---

## ‚úÖ Action Plan Summary:

| Task                                  | Priority     | Notes                                 |
| ------------------------------------- | ------------ | ------------------------------------- |
| üîó Update models to add relationships | üî• Must-have | e.g. `vendor` in Product              |
| üì¶ Add tracking models                | üî• Must-have | Viewed, Cart, Orders                  |
| üîÑ Update serializers                 | ‚úÖ Important  | Use `depth=1` or nested serializers   |
| üîå Create DRF API views               | üî• Must-have | Use class-based views or ViewSets     |
| üîÅ Connect React frontend             | üöß Next step | Use Axios/fetch to populate dashboard |

---

Would you like me to:

1. Generate **serializers and API views**?
2. Help design the **React calls** to fetch this data?
3. Build a **full backend dashboard API** in DRF?

Let me know where you want to go from here.



link: 
https://chatgpt.com/share/685fc97a-dc04-8000-b167-e8ad705322e7



from django.db.models import Q
To track the status of an **ordered product** (such as `OrderPlaced`, `Packed`, `Shipped`, `Delivered`, etc.), you can make use of the **`OrderItem` model** and add a new field like `status` to represent the status of each product in an order.

The order itself can have a general **status** (like `Pending`, `Shipped`, etc.), but if you want to track the individual **status** of each product within the order (e.g., if some products are packed and others are shipped), you should add the **`status` field** to the `OrderItem` model.

### Steps:

1. **Add `status` field to the `OrderItem` model**:

   * This field will track the status of the individual product within the order (e.g., `order placed`, `packed`, `shipped`, `delivered`).

2. **Define status choices** for the product status within the order.

3. **Update order statuses** to ensure that the order status reflects the status of the items inside it, or you can leave that independent.

### Example: Adding `status` to `OrderItem` model:

You can add a `status` field to the `OrderItem` model to track the status of each product in the order, like this:

```python
class OrderItem(models.Model):
    STATUS_CHOICES = (
        ('order_placed', 'Order Placed'),
        ('packed', 'Packed'),
        ('shipped', 'Shipped'),
        ('delivered', 'Delivered'),
        ('returned', 'Returned'),
    )

    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name="items")
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    vendor = models.ForeignKey(RomoUserRegistration, on_delete=models.CASCADE, null=True, blank=True)
    quantity = models.PositiveIntegerField()
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='order_placed')

    def __str__(self):
        return f"{self.product.product_name} - {self.status}"
```

### Explanation:

* **`status` field**: The `status` field will track the individual status of each product in the order. It uses the **`STATUS_CHOICES`** tuple to limit the possible values to `order_placed`, `packed`, `shipped`, `delivered`, and `returned`.

* **`default='order_placed'`**: When a new `OrderItem` is created, it starts with a status of `order_placed`, meaning the product has been added to the order but hasn't been processed yet.

### Order Status vs OrderItem Status:

* The **`Order` model** can still track the **overall status** of the order (e.g., `Pending`, `Shipped`, `Delivered`).
* However, the **`OrderItem` model** tracks the status of each product in the order individually. This allows you to track whether each product is `shipped`, `packed`, or `delivered` independently of the others.

#### Example `Order` Model:

If you want to track the overall order status (which could be more general), you can continue using the `status` field in the `Order` model.

```python
class Order(models.Model):
    STATUS_CHOICES = (
        ('pending', 'Pending'),
        ('order_placed', 'Order Placed'),
        ('shipped', 'Shipped'),
        ('delivered', 'Delivered'),
        ('cancelled', 'Cancelled'),
    )

    customer = models.ForeignKey(RomoUserRegistration, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    is_paid = models.BooleanField(default=False)
    status = models.CharField(max_length=30, default='pending', choices=STATUS_CHOICES)

    def __str__(self):
        return f"Order {self.id} - {self.status}"
```

* **Overall order status (`Order.status`)** could be one of: `pending`, `shipped`, `delivered`, etc.
* **Individual item status (`OrderItem.status`)** can track more detailed progress per product (e.g., `packed`, `shipped`).

### Updating Statuses:

1. **Order Item**: When a product's status changes (e.g., it gets packed or shipped), you can update the `status` field on the `OrderItem` instance.

   Example:

   ```python
   order_item = OrderItem.objects.get(id=1)
   order_item.status = 'packed'  # Change to 'shipped' or 'delivered' as needed
   order_item.save()
   ```

2. **Order**: You might want to update the order's overall status based on the status of its items. You can create a method to determine the order's status based on the statuses of its `OrderItems`.

### Example: Updating Order Status Based on Items

If you want to update the order status based on the status of the `OrderItems`, you can create a method in the `Order` model to check if all items have been delivered.

```python
class Order(models.Model):
    STATUS_CHOICES = (
        ('pending', 'Pending'),
        ('order_placed', 'Order Placed'),
        ('shipped', 'Shipped'),
        ('delivered', 'Delivered'),
        ('cancelled', 'Cancelled'),
    )

    customer = models.ForeignKey(RomoUserRegistration, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    is_paid = models.BooleanField(default=False)
    status = models.CharField(max_length=30, default='pending', choices=STATUS_CHOICES)

    def update_status(self):
        # Check if all items are delivered
        if all(item.status == 'delivered' for item in self.items.all()):
            self.status = 'delivered'
        elif any(item.status == 'shipped' for item in self.items.all()):
            self.status = 'shipped'
        else:
            self.status = 'order_placed'
        self.save()

    def __str__(self):
        return f"Order {self.id} - {self.status}"
```

* **`update_status()`**: This method checks if all `OrderItem` statuses are `delivered` and updates the `Order` status accordingly.
* You can call `order.update_status()` whenever the status of an `OrderItem` changes.

### Summary:

* **Add a `status` field to the `OrderItem` model** to track the status of each individual product (e.g., `order_placed`, `packed`, `shipped`, `delivered`).
* The **`Order` model** can have a general status (`pending`, `shipped`, etc.).
* You can **update the order status** based on the statuses of its `OrderItems`, using a custom method like `update_status()`.

This approach allows you to track both the overall order status and the status of each individual product within the order.
